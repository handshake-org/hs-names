#!/usr/bin/env node

'use strict';

/* eslint quotes: off */

const assert = require('assert');
const Path = require('path');
const fs = require('bfile');
// const bio = require('bufio');
const {Resource} = require('hsd/lib/dns/resource');
const util = require('./util');

const ZONE_JSON = Path.resolve(__dirname, 'build', 'root.json');
const TLD_H = Path.resolve(__dirname, 'build', 'tld.h');
// const TLD_JSON = Path.resolve(__dirname, 'build', 'tld.json');
// const TLD_DB = Path.resolve(__dirname, 'build', 'tld.db');

function prepend(data) {
  assert(data.length <= 512);

  const out = Buffer.allocUnsafe(2 + data.length);

  out.writeUInt16LE(data.length, 0);
  data.copy(out, 2);

  return out;
}

function toHex(data) {
  const hex = prepend(data).toString('hex');
  const chunks = [];

  for (let i = 0; i < hex.length; i += 26)
    chunks.push(`  "${hex.slice(i, i + 26)}"`);

  const str = chunks.join('\n');
  const cstr = str.replace(/([a-f0-9]{2})/g, '\\x$1');

  return `${cstr},`;
}

function toWire(name) {
  let str = '  ';
  str +=    `"\\x${name.length.toString(16).padStart(2, '0')}"`;
  str +=    `"${name}"`;
  str +=    '"\\x00",';
  return str;
}

const json = fs.readFileSync(ZONE_JSON, 'utf8');
const root = JSON.parse(json);
const keys = Object.keys(root).sort(util.compare);
const items = [];

for (const key of keys) {
  const res = Resource.fromJSON(root[key]);
  const blob = res.encode();

  assert(blob.length <= 512);

  items.push([key.slice(0, -1), blob]);
}

{
  const code = [
    '#ifndef _HSK_TLD_H',
    '#define _HSK_TLD_H',
    '',
    '/* Autogenerated, do not edit. */',
    '',
    `#define HSK_TLD_SIZE ${keys.length}`,
    '',
    'static const char *HSK_TLD_NAMES[] = {'
  ];

  for (const [name] of items)
    code.push(toWire(name));

  code.push('  NULL');
  code.push('};');
  code.push('');
  code.push('static const char *HSK_TLD_DATA[] = {');

  for (const [, blob] of items)
    code.push(toHex(blob));

  code.push('  NULL');
  code.push('};');
  code.push('');
  code.push('#endif');
  code.push('');

  fs.writeFileSync(TLD_H, code.join('\n'));
}

// {
//   const json = [
//     '{'
//   ];

//   for (const [name, blob] of items)
//     json.push(`  "${name}": "${blob.toString('base64')}",`);

//   json[json.length - 1] = json[json.length - 1].slice(0, -1);
//   json.push('}');
//   json.push('');

//   fs.writeFileSync(TLD_JSON, json.join('\n'));
// }

// {
//   const bw = bio.write(10 << 20);
//   const {data} = bw;

//   let nameSize = 0;

//   for (const [name] of items) {
//     if (name.length > nameSize)
//       nameSize = name.length;
//   }

//   if (nameSize > 32)
//     throw new Error('Upgrade serialization!');

//   assert(nameSize <= 63);

//   bw.writeU32(items.length);
//   bw.writeU8(nameSize);

//   const offsets = [];

//   for (const [name] of items) {
//     bw.writeU8(name.length);
//     bw.writeString(name, 'ascii');
//     bw.fill(0x00, nameSize - name.length);
//     offsets.push(bw.offset);
//     bw.writeU32(0);
//   }

//   for (let i = 0; i < items.length; i++) {
//     const [, blob] = items[i];
//     const {offset} = bw;
//     const pos = offsets[i];

//     bio.writeU32(data, offset, pos);

//     assert(blob.length <= 512);
//     bw.writeU16(blob.length);
//     bw.writeBytes(blob);
//   }

//   const raw = bw.slice();

//   fs.writeFileSync(TLD_DB, raw);
// }
