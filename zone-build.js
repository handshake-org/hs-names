#!/usr/bin/env node

'use strict';

/* eslint quotes: off */

const assert = require('assert');
const Path = require('path');
const fs = require('bfile');
const bio = require('bufio');
const Resource = require('hskd/lib/dns/resource');
const util = require('./util');

const ZONE_JSON = Path.resolve(__dirname, 'build', 'root.json');
const TLD_H = Path.resolve(__dirname, 'build', 'tld.h');
const TLD_JSON = Path.resolve(__dirname, 'build', 'tld.json');
const TLD_DB = Path.resolve(__dirname, 'build', 'tld.db');

function prepend(data) {
  assert(data.length <= 512);

  const out = Buffer.allocUnsafe(2 + data.length);

  out.writeUInt16LE(data.length, 0);
  data.copy(out, 2);

  return out;
}

function toHex(data) {
  const hex = prepend(data).toString('hex');
  const chunks = [];

  for (let i = 0; i < hex.length; i += 26)
    chunks.push(`  "${hex.slice(i, i + 26)}"`);

  const str = chunks.join('\n');
  const cstr = str.replace(/([a-f0-9]{2})/g, '\\x$1');

  return `${cstr},`;
}

const json = fs.readFileSync(ZONE_JSON, 'utf8');
const root = JSON.parse(json);
const keys = Object.keys(root).sort(util.compare);
const items = [];

for (const key of keys) {
  const res = Resource.fromJSON(root[key]);
  const blob = res.encode();

  items.push([key.slice(0, -1), blob]);
}

{
  const code = [
    '#ifndef _HSK_TLD_H',
    '#define _HSK_TLD_H',
    '',
    '/* Autogenerated, do not edit. */',
    '',
    `#define HSK_TLD_SIZE ${keys.length}`,
    '',
    'static const char *HSK_TLD_NAMES[] = {'
  ];

  for (const [name] of items)
    code.push(`  "${name}",`);

  code.push('  NULL');
  code.push('};');
  code.push('');
  code.push('static const char *HSK_TLD_DATA[] = {');

  for (const [, blob] of items)
    code.push(toHex(blob));

  code.push('  NULL');
  code.push('};');
  code.push('');
  code.push('#endif');
  code.push('');

  fs.writeFileSync(TLD_H, code.join('\n'));
}

{
  const json = [
    '{'
  ];

  for (const [name, blob] of items)
    json.push(`  "${name}": "${blob.toString('base64')}",`);

  json[json.length - 1] = json[json.length - 1].slice(0, -1);
  json.push('}');
  json.push('');

  fs.writeFileSync(TLD_JSON, json.join('\n'));
}

{
  const bw = bio.write(10 << 20);
  const {data} = bw;

  let nameSize = 0;

  for (const [name] of items) {
    if (name.length > nameSize)
      nameSize = name.length;
  }

  if (nameSize > 32)
    throw new Error('Upgrade serialization!');

  assert(nameSize <= 63);

  bw.writeU32(items.length);
  bw.writeU8(nameSize);

  const offsets = [];

  for (const [name] of items) {
    bw.writeU8(name.length);
    bw.writeString(name, 'ascii');
    bw.fill(0x00, nameSize - name.length);
    offsets.push(bw.offset);
    bw.writeU32(0);
  }

  for (let i = 0; i < items.length; i++) {
    const [, blob] = items[i];
    const {offset} = bw;
    const pos = offsets[i];

    bio.writeU32(data, offset, pos);

    assert(blob.length <= 512);
    bw.writeU16(blob.length);
    bw.writeBytes(blob);
  }

  const raw = bw.slice();

  fs.writeFileSync(TLD_DB, raw);
}
